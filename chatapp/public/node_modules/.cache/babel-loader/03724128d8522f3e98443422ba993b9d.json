{"ast":null,"code":"import { encodePacket, encodePacketToBinary } from \"./encodePacket.js\";\nimport { decodePacket } from \"./decodePacket.js\";\nconst SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\n\nconst encodePayload = (packets, callback) => {\n  // some packets may be added to the array while encoding, so the initial length must be saved\n  const length = packets.length;\n  const encodedPackets = new Array(length);\n  let count = 0;\n  packets.forEach((packet, i) => {\n    // force base64 encoding for binary packets\n    encodePacket(packet, false, encodedPacket => {\n      encodedPackets[i] = encodedPacket;\n\n      if (++count === length) {\n        callback(encodedPackets.join(SEPARATOR));\n      }\n    });\n  });\n};\n\nconst decodePayload = (encodedPayload, binaryType) => {\n  const encodedPackets = encodedPayload.split(SEPARATOR);\n  const packets = [];\n\n  for (let i = 0; i < encodedPackets.length; i++) {\n    const decodedPacket = decodePacket(encodedPackets[i], binaryType);\n    packets.push(decodedPacket);\n\n    if (decodedPacket.type === \"error\") {\n      break;\n    }\n  }\n\n  return packets;\n};\n\nlet TEXT_DECODER;\nexport function decodePacketFromBinary(data, isBinary, binaryType) {\n  if (!TEXT_DECODER) {\n    // lazily created for compatibility with old browser platforms\n    TEXT_DECODER = new TextDecoder();\n  } // 48 === \"0\".charCodeAt(0) (OPEN packet type)\n  // 54 === \"6\".charCodeAt(0) (NOOP packet type)\n\n\n  const isPlainBinary = isBinary || data[0] < 48 || data[0] > 54;\n  return decodePacket(isPlainBinary ? data : TEXT_DECODER.decode(data), binaryType);\n}\nexport const protocol = 4;\nexport { encodePacket, encodePacketToBinary, encodePayload, decodePacket, decodePayload };","map":{"version":3,"sources":["C:/Users/Admin/Desktop/ChatApp/chatapp/public/node_modules/engine.io-parser/build/esm/index.js"],"names":["encodePacket","encodePacketToBinary","decodePacket","SEPARATOR","String","fromCharCode","encodePayload","packets","callback","length","encodedPackets","Array","count","forEach","packet","i","encodedPacket","join","decodePayload","encodedPayload","binaryType","split","decodedPacket","push","type","TEXT_DECODER","decodePacketFromBinary","data","isBinary","TextDecoder","isPlainBinary","decode","protocol"],"mappings":"AAAA,SAASA,YAAT,EAAuBC,oBAAvB,QAAmD,mBAAnD;AACA,SAASC,YAAT,QAA6B,mBAA7B;AACA,MAAMC,SAAS,GAAGC,MAAM,CAACC,YAAP,CAAoB,EAApB,CAAlB,C,CAA2C;;AAC3C,MAAMC,aAAa,GAAG,CAACC,OAAD,EAAUC,QAAV,KAAuB;AACzC;AACA,QAAMC,MAAM,GAAGF,OAAO,CAACE,MAAvB;AACA,QAAMC,cAAc,GAAG,IAAIC,KAAJ,CAAUF,MAAV,CAAvB;AACA,MAAIG,KAAK,GAAG,CAAZ;AACAL,EAAAA,OAAO,CAACM,OAAR,CAAgB,CAACC,MAAD,EAASC,CAAT,KAAe;AAC3B;AACAf,IAAAA,YAAY,CAACc,MAAD,EAAS,KAAT,EAAgBE,aAAa,IAAI;AACzCN,MAAAA,cAAc,CAACK,CAAD,CAAd,GAAoBC,aAApB;;AACA,UAAI,EAAEJ,KAAF,KAAYH,MAAhB,EAAwB;AACpBD,QAAAA,QAAQ,CAACE,cAAc,CAACO,IAAf,CAAoBd,SAApB,CAAD,CAAR;AACH;AACJ,KALW,CAAZ;AAMH,GARD;AASH,CAdD;;AAeA,MAAMe,aAAa,GAAG,CAACC,cAAD,EAAiBC,UAAjB,KAAgC;AAClD,QAAMV,cAAc,GAAGS,cAAc,CAACE,KAAf,CAAqBlB,SAArB,CAAvB;AACA,QAAMI,OAAO,GAAG,EAAhB;;AACA,OAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,cAAc,CAACD,MAAnC,EAA2CM,CAAC,EAA5C,EAAgD;AAC5C,UAAMO,aAAa,GAAGpB,YAAY,CAACQ,cAAc,CAACK,CAAD,CAAf,EAAoBK,UAApB,CAAlC;AACAb,IAAAA,OAAO,CAACgB,IAAR,CAAaD,aAAb;;AACA,QAAIA,aAAa,CAACE,IAAd,KAAuB,OAA3B,EAAoC;AAChC;AACH;AACJ;;AACD,SAAOjB,OAAP;AACH,CAXD;;AAYA,IAAIkB,YAAJ;AACA,OAAO,SAASC,sBAAT,CAAgCC,IAAhC,EAAsCC,QAAtC,EAAgDR,UAAhD,EAA4D;AAC/D,MAAI,CAACK,YAAL,EAAmB;AACf;AACAA,IAAAA,YAAY,GAAG,IAAII,WAAJ,EAAf;AACH,GAJ8D,CAK/D;AACA;;;AACA,QAAMC,aAAa,GAAGF,QAAQ,IAAID,IAAI,CAAC,CAAD,CAAJ,GAAU,EAAtB,IAA4BA,IAAI,CAAC,CAAD,CAAJ,GAAU,EAA5D;AACA,SAAOzB,YAAY,CAAC4B,aAAa,GAAGH,IAAH,GAAUF,YAAY,CAACM,MAAb,CAAoBJ,IAApB,CAAxB,EAAmDP,UAAnD,CAAnB;AACH;AACD,OAAO,MAAMY,QAAQ,GAAG,CAAjB;AACP,SAAShC,YAAT,EAAuBC,oBAAvB,EAA6CK,aAA7C,EAA4DJ,YAA5D,EAA0EgB,aAA1E","sourcesContent":["import { encodePacket, encodePacketToBinary } from \"./encodePacket.js\";\nimport { decodePacket } from \"./decodePacket.js\";\nconst SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\nconst encodePayload = (packets, callback) => {\n    // some packets may be added to the array while encoding, so the initial length must be saved\n    const length = packets.length;\n    const encodedPackets = new Array(length);\n    let count = 0;\n    packets.forEach((packet, i) => {\n        // force base64 encoding for binary packets\n        encodePacket(packet, false, encodedPacket => {\n            encodedPackets[i] = encodedPacket;\n            if (++count === length) {\n                callback(encodedPackets.join(SEPARATOR));\n            }\n        });\n    });\n};\nconst decodePayload = (encodedPayload, binaryType) => {\n    const encodedPackets = encodedPayload.split(SEPARATOR);\n    const packets = [];\n    for (let i = 0; i < encodedPackets.length; i++) {\n        const decodedPacket = decodePacket(encodedPackets[i], binaryType);\n        packets.push(decodedPacket);\n        if (decodedPacket.type === \"error\") {\n            break;\n        }\n    }\n    return packets;\n};\nlet TEXT_DECODER;\nexport function decodePacketFromBinary(data, isBinary, binaryType) {\n    if (!TEXT_DECODER) {\n        // lazily created for compatibility with old browser platforms\n        TEXT_DECODER = new TextDecoder();\n    }\n    // 48 === \"0\".charCodeAt(0) (OPEN packet type)\n    // 54 === \"6\".charCodeAt(0) (NOOP packet type)\n    const isPlainBinary = isBinary || data[0] < 48 || data[0] > 54;\n    return decodePacket(isPlainBinary ? data : TEXT_DECODER.decode(data), binaryType);\n}\nexport const protocol = 4;\nexport { encodePacket, encodePacketToBinary, encodePayload, decodePacket, decodePayload };\n"]},"metadata":{},"sourceType":"module"}