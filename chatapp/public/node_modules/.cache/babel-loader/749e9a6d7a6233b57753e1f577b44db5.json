{"ast":null,"code":"import { Transport } from \"../transport.js\";\nimport { nextTick } from \"./websocket-constructor.js\";\nimport { encodePacketToBinary, decodePacketFromBinary } from \"engine.io-parser\";\n\nfunction shouldIncludeBinaryHeader(packet, encoded) {\n  // 48 === \"0\".charCodeAt(0) (OPEN packet type)\n  // 54 === \"6\".charCodeAt(0) (NOOP packet type)\n  return packet.type === \"message\" && typeof packet.data !== \"string\" && encoded[0] >= 48 && encoded[0] <= 54;\n}\n\nexport class WT extends Transport {\n  get name() {\n    return \"webtransport\";\n  }\n\n  doOpen() {\n    // @ts-ignore\n    if (typeof WebTransport !== \"function\") {\n      return;\n    } // @ts-ignore\n\n\n    this.transport = new WebTransport(this.createUri(\"https\"), this.opts.transportOptions[this.name]);\n    this.transport.closed.then(() => {\n      this.onClose();\n    }).catch(err => {\n      this.onError(\"webtransport error\", err);\n    }); // note: we could have used async/await, but that would require some additional polyfills\n\n    this.transport.ready.then(() => {\n      this.transport.createBidirectionalStream().then(stream => {\n        const reader = stream.readable.getReader();\n        this.writer = stream.writable.getWriter();\n        let binaryFlag;\n\n        const read = () => {\n          reader.read().then(_ref => {\n            let {\n              done,\n              value\n            } = _ref;\n\n            if (done) {\n              return;\n            }\n\n            if (!binaryFlag && value.byteLength === 1 && value[0] === 54) {\n              binaryFlag = true;\n            } else {\n              // TODO expose binarytype\n              this.onPacket(decodePacketFromBinary(value, binaryFlag, \"arraybuffer\"));\n              binaryFlag = false;\n            }\n\n            read();\n          }).catch(err => {});\n        };\n\n        read();\n        const handshake = this.query.sid ? `0{\"sid\":\"${this.query.sid}\"}` : \"0\";\n        this.writer.write(new TextEncoder().encode(handshake)).then(() => this.onOpen());\n      });\n    });\n  }\n\n  write(packets) {\n    this.writable = false;\n\n    for (let i = 0; i < packets.length; i++) {\n      const packet = packets[i];\n      const lastPacket = i === packets.length - 1;\n      encodePacketToBinary(packet, data => {\n        if (shouldIncludeBinaryHeader(packet, data)) {\n          this.writer.write(Uint8Array.of(54));\n        }\n\n        this.writer.write(data).then(() => {\n          if (lastPacket) {\n            nextTick(() => {\n              this.writable = true;\n              this.emitReserved(\"drain\");\n            }, this.setTimeoutFn);\n          }\n        });\n      });\n    }\n  }\n\n  doClose() {\n    var _a;\n\n    (_a = this.transport) === null || _a === void 0 ? void 0 : _a.close();\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Admin/Desktop/ChatApp/chatapp/public/node_modules/engine.io-client/build/esm/transports/webtransport.js"],"names":["Transport","nextTick","encodePacketToBinary","decodePacketFromBinary","shouldIncludeBinaryHeader","packet","encoded","type","data","WT","name","doOpen","WebTransport","transport","createUri","opts","transportOptions","closed","then","onClose","catch","err","onError","ready","createBidirectionalStream","stream","reader","readable","getReader","writer","writable","getWriter","binaryFlag","read","done","value","byteLength","onPacket","handshake","query","sid","write","TextEncoder","encode","onOpen","packets","i","length","lastPacket","Uint8Array","of","emitReserved","setTimeoutFn","doClose","_a","close"],"mappings":"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","sourcesContent":["import { Transport } from \"../transport.js\";\nimport { nextTick } from \"./websocket-constructor.js\";\nimport { encodePacketToBinary, decodePacketFromBinary, } from \"engine.io-parser\";\nfunction shouldIncludeBinaryHeader(packet, encoded) {\n    // 48 === \"0\".charCodeAt(0) (OPEN packet type)\n    // 54 === \"6\".charCodeAt(0) (NOOP packet type)\n    return (packet.type === \"message\" &&\n        typeof packet.data !== \"string\" &&\n        encoded[0] >= 48 &&\n        encoded[0] <= 54);\n}\nexport class WT extends Transport {\n    get name() {\n        return \"webtransport\";\n    }\n    doOpen() {\n        // @ts-ignore\n        if (typeof WebTransport !== \"function\") {\n            return;\n        }\n        // @ts-ignore\n        this.transport = new WebTransport(this.createUri(\"https\"), this.opts.transportOptions[this.name]);\n        this.transport.closed\n            .then(() => {\n            this.onClose();\n        })\n            .catch((err) => {\n            this.onError(\"webtransport error\", err);\n        });\n        // note: we could have used async/await, but that would require some additional polyfills\n        this.transport.ready.then(() => {\n            this.transport.createBidirectionalStream().then((stream) => {\n                const reader = stream.readable.getReader();\n                this.writer = stream.writable.getWriter();\n                let binaryFlag;\n                const read = () => {\n                    reader\n                        .read()\n                        .then(({ done, value }) => {\n                        if (done) {\n                            return;\n                        }\n                        if (!binaryFlag && value.byteLength === 1 && value[0] === 54) {\n                            binaryFlag = true;\n                        }\n                        else {\n                            // TODO expose binarytype\n                            this.onPacket(decodePacketFromBinary(value, binaryFlag, \"arraybuffer\"));\n                            binaryFlag = false;\n                        }\n                        read();\n                    })\n                        .catch((err) => {\n                    });\n                };\n                read();\n                const handshake = this.query.sid ? `0{\"sid\":\"${this.query.sid}\"}` : \"0\";\n                this.writer\n                    .write(new TextEncoder().encode(handshake))\n                    .then(() => this.onOpen());\n            });\n        });\n    }\n    write(packets) {\n        this.writable = false;\n        for (let i = 0; i < packets.length; i++) {\n            const packet = packets[i];\n            const lastPacket = i === packets.length - 1;\n            encodePacketToBinary(packet, (data) => {\n                if (shouldIncludeBinaryHeader(packet, data)) {\n                    this.writer.write(Uint8Array.of(54));\n                }\n                this.writer.write(data).then(() => {\n                    if (lastPacket) {\n                        nextTick(() => {\n                            this.writable = true;\n                            this.emitReserved(\"drain\");\n                        }, this.setTimeoutFn);\n                    }\n                });\n            });\n        }\n    }\n    doClose() {\n        var _a;\n        (_a = this.transport) === null || _a === void 0 ? void 0 : _a.close();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}